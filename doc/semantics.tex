\documentclass[fleqn]{amsart}
\usepackage[margin={0.25in}]{geometry}
\newcommand{\zeroarity}[1]{&\ \textit{#1*}\quad\text{-- where }\textit{#1*}\text{ is }(#1)}
\newcommand{\positive}[1]{&\ \textit{#1}\ Int\quad\text{-- where }Int\text{ is positive}}
\newcommand{\integer}[1]{&\ #1\ Int}
\newcommand{\predicate}[2]{&\ \textit{#1}\ (#2 \rightarrow Boolean)}
\newcommand{\nonnillable}[3]{&\ \textit{#1}\ (#2 \rightarrow #3)\quad\text{-- where }#3\text{ is not nil}}
\newcommand{\any}[3]{&\ \textit{#1}\ (#2 \rightarrow #3)}
\begin{document}
\begin{align*}
  \mathbf{type}\ E_a = [(\hat{T}, a)]\quad\text{-- for strictly increasing times}
\end{align*}
\begin{align*}
  occs\ (>>= e\ f) = foldr\ merge\ []\circ map\ delayOccs\circ map\ (\lambda(\hat{t}_a, a) \rightarrow (\hat{t}_a , f\ a))\ \$ \ occs\ e
\end{align*}
\begin{align*}
  \mathbf{data}\ Xform\ a\ b\ c\ d\ e\ f\ g\ h\ i\ j\ k\ l\ m\ n =\zeroarity{dedupe}\\
  |\zeroarity{distinct}\\
  |\positive{take-nth}\\
  |\positive{partition-all}\\
  |\integer{drop}\\
  |\integer{take}\\
  |&\ replace\ Map\ a\ b\\
  |\predicate{drop-while}{c}\\
  |\predicate{filter}{d}\\
  |\predicate{remove}{e}\\
  |\predicate{take-while}{f}\\
  |\nonnillable{map-index}{g}{h}\\
  |\nonnillable{partition-by}{i}{j}\\
  |\any{keep}{k}{l}\\
  |\any{keep-indexed}{m}{n}
\end{align*}
\begin{align*}
  transduce :: Xform \rightarrow (a \rightarrow b \rightarrow a) \rightarrow a \rightarrow Event\ b \rightarrow Event\ a
\end{align*}
\begin{align*}
  &occs\ (transduce\ xform\ f\ a\ e)\\
  &\quad= scanl\ (liftA2\ f)\ a\ \$\ mapMaybe\ (unreduced\ .\ (xform\ (\lambda\_\ x\rightarrow just\ x))\ nothing)\ \$\ occs\ e
\end{align*}
\begin{align*}
  >>= :: Behavior\ a \rightarrow f \rightarrow Behavior\ b
\end{align*}
\begin{align*}
  at\ (>>= b\ f) =\lambda t \rightarrow f\ (b\ `at` \ t)\ `at` \ t
\end{align*}
\begin{align*}
  calculus :: Real\ a\Rightarrow (a \rightarrow a \rightarrow Time \rightarrow Time \rightarrow a \rightarrow a) \rightarrow Maybe\ Time \rightarrow Behavior\ a\rightarrow Behavior\ Maybe\ a
\end{align*}
\begin{align*}
  \forall\epsilon\exists\delta\forall t(&\epsilon > 0\\
  \wedge& t > 0\\
  \wedge& (0 < t - a < \delta \implies(at\ (calculus\ f\ x\ b))\ t - f\ ((at\ b)\ t)\ ((at\ b)\ (t - a))\ t\ (t - a)\ \$\ at\ \$\ calculus\ f \ x\ b))
\end{align*}
\begin{align*}
  &\mathbf{class}\ Entity\ e\ \mathbf{where}\\
  &\quad on :: (a\rightarrow IO\ ())\rightarrow e \rightarrow IO\ ()
\end{align*}
\begin{align*}
  &\mathbf{instance_{sem}}\ Entity\ (Event\ a)\ \mathbf{where}\\
  &\quad occs\ \$\ on\ f\ e = map\ (fmap\ f)\ \$\ biasedOccs\ e
\end{align*}
\begin{align*}
  &\mathbf{instance_{sem}}\ Entity\ (Behavior\ a)\ \mathbf{where}\\
  &\quad occs\ \$\ on\ f\ b = map\ ((fmap\ f)\ .\ dedupe)\ \$\ (biasedOccs\ e)\oplus((t\rightarrow (t, (at\ b)\ t))\ \langle\$\rangle\ [time\ \$\ n * internal + error_n])\\
  &\qquad\text{-- where }b = (a\ stepper\ e)\wedge (n\geq 0)\wedge (interval > 0)\wedge (n * internal + error_n) < ((n + 1) * internal + error_{n+1})
\end{align*}
\end{document}
